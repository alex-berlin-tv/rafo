"""
This module contains a thin wrapper around the Baserow Client library.
"""

import abc
from pydantic.fields import computed_field
from pydantic.main import create_model
from .config import settings
from .log import logger

from typing import Any, ClassVar, Generic, List, Optional, Type, TypeVar, Union

from baserow.client import ApiError, BaserowClient
from baserow.filter import Column, Filter
from pydantic import BaseModel, ConfigDict, Field
from pydantic.root_model import RootModel


T = TypeVar("T", bound="Table")


class NoSingleResultFoundError(Exception):
    """
    Exception which is thrown if, contrary to the instruction, more than one
    entry is found by a query.
    """
    pass


class NoResultError(Exception):
    """
    If a query is expected to return at least one record but none are found,
    this exception will be thrown.
    """


class RowLink(BaseModel):
    """A single link to another table."""
    row_id: int = Field(alias="id")
    key: Optional[str] = Field(alias="value")


class TableLinkField(RootModel[list[RowLink]]):
    """
    Table link field. Can contain one or more links to rows in another table.
    """
    root: list[RowLink]

    def id_str(self) -> str:
        """Returns a list of all ID's as string for debugging."""
        return ",".join([str(link.row_id) for link in self.root])


class MultipleSelectEntry(BaseModel):
    """A entry in a multiple select field."""
    entry_id: int = Field(alias="id")
    value: str
    color: str


class MultipleSelectField(RootModel[list[MultipleSelectEntry]]):
    """Multiple select field in a table."""
    root: list[MultipleSelectEntry]


class Client(BaserowClient):
    """
    Encapsulates the baserow client into a singleton and provides some extra validation methods.
    """
    _instance = None
    __initialized = False

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.__initialized = False
        return cls._instance

    def __init__(self):
        if not self.__initialized:
            super().__init__(settings.baserow_url, token=settings.baserow_api_key)
            self.__initialized = True


class Result(Generic[T]):
    """
    Result of a query. Supports additional checking and post-processing of
    results.
    """

    def __init__(self, value: list[T], query_explanation: str = ""):
        """
        The query_explanation provides a clear and understandable explanation of
        the query that the result is based on. It is used in error messages
        generated by the filters. Should complete the sentence "when...".
        """
        self.__value = value
        self.__query_description = query_explanation

    def any(self) -> list[T]:
        """Returns the result as list without any additional checks."""
        return self.__value

    def one(self) -> T:
        """
        Exactly one entry is expected to be within the result. This is useful,
        for example, if you're searching for an existing entry by its unique ID.
        If this requirement is not met, a `NoSingleResultFoundError` is thrown.
        """
        if len(self.__value) == 0:
            raise NoSingleResultFoundError(
                f"empty result when {self.__query_description}, exactly one result expected"
            )
        if len(self.__value) > 1:
            raise NoSingleResultFoundError(
                f"more than one result when {self.__query_description}, exactly one result expected"
            )
        return self.__value[0]

    def not_none(self) -> list[T]:
        """Returns the result(s) as a list if there is at least one record present."""
        if len(self.__value) == 0:
            raise NoResultError(
                f"expected at least one record when {self.__query_description}, zero results were returned"
            )
        return self.__value

    def is_empty(self) -> bool:
        """Checks whether result contains any results."""
        return len(self.__value) > 0


class Table(BaseModel, abc.ABC):
    """
    Encapsulates the most common interactions with a baserow table by binding it to a pydantic
    BaseModel.
    """

    @property
    @abc.abstractmethod
    def table_id(cls) -> int:  # type: ignore
        """
        The Baserow table ID. Every table in Baserow has a unique ID. This means
        that each model is linked to a specific table. It's not currently
        possible to bind a table model to multiple tables.
        """
        raise NotImplementedError()

    @property
    @abc.abstractmethod
    def table_name(cls) -> str:  # type: ignore
        """
        Each table model must have a human-readable table name. The name is used
        for debugging information only and has no role in addressing/interacting
        with the Baserow table. Ideally this should be the same name used for
        the table within the Baserow UI.
        """
        raise NotImplementedError()

    table_id: ClassVar[int]
    table_name: ClassVar[str]

    @classmethod
    def validate_baserow(cls):
        """
        Checks if the given table id's exist in the Baserow backend. And the given user field
        names exist in the table.
        """
        aliases = [field.alias for _, field in cls.model_fields.items()]
        try:
            result = Client().list_database_table_fields(cls.table_id)
            field_names = [field.name for field in result]
            for alias in aliases:
                if alias not in field_names and alias != "id":
                    raise RuntimeError(
                        f"Field '{alias}' not found in Baserow {cls.table_name} table {cls.table_id}"
                    )
        except ApiError as e:
            if e.args[0] == "ERROR_TABLE_DOES_NOT_EXIST":
                raise RuntimeError(
                    f"There is no {cls.table_name} table in baserow for id {cls.table_id}")
            raise e

    @classmethod
    def query(
        cls: Type[T],
        filter: List[Filter],
    ) -> Result[T]:
        """
        Queries rows in the table If no results are found, the function will
        return `None`. Otherwise, the results will be returned as a list. The
        model instance will only be returned without being encapsulated in a
        list if `one` is set.

        Args:
            filter: List of filter which should be applied to the query. Provide
                empty list if no filtering is desired. 
            one: Set to `True` if exactly one entry is expected to be found.
                This is useful, for example, if you're searching for an existing
                entry by its unique ID. If this requirement is not met, a
                `NoSingleResultFoundError` is thrown. Cannot be set at the same
                time as `not_none`.
            not_none: Use this if you expect your query to return at least one
                record. Will throw a `NoResultError' if the query returns an
                empty result.Cannot be set at the same time as `one`.
        """
        response = Client().list_database_table_rows(
            cls.table_id,
            filter=filter,
            user_field_names=True,
        )
        return Result(
            [cls.model_validate(result) for result in response.results],
            f"querying  table {cls.table_id} ({cls.table_name}) with filter '{filter}'",
        )

    @classmethod
    def by_uuid(cls: Type[T], uuid: str) -> Result[T]:
        logger.debug(f"baserow query in {cls.table_name} by UUID {uuid}")
        return cls.query([Column("UUID").equal(uuid)])

    @classmethod
    def by_id(cls: Type[T], row_id: int) -> Result[T]:
        """
        Retrieve an entry by its unique row ID.
        """
        logger.debug(f"baserow query in {cls.table_name} by ID {row_id}")
        response = Client().get_database_table_row(
            cls.table_id,
            row_id,
            user_field_names=True,
        )
        return Result(
            [cls.model_validate(response)],
            f"querying the table with the unique ID '{row_id}' for {cls.table_name} ({cls.table_id})",
        )

    @classmethod
    def by_link_field(
        cls: Type[T],
        link_field: TableLinkField,
    ) -> Result[T]:
        """
        Get entries by a TableLinkField values. Used to retrieve linked table rows.

        Args:
            one: Set to `True` if exactly one entry is expected to be found.
                This is useful, for example, if you're searching for an existing
                entry by its unique ID. If this requirement is not met, a
                `NoSingleResultFoundError` is thrown. Cannot be set at the same
                time as `not_none`.
            not_none: Use this if you expect your query to return at least one
                record. Will throw a `NoResultError' if the query returns an
                empty result.Cannot be set at the same time as `one`.
        """
        description = f"query in {cls.table_name} for linked fields with ID's [{link_field.id_str()}]"
        logger.debug(
            f"baserow {description}"
        )
        rsl: List[T] = []
        try:
            for link in link_field.root:
                rsl.append(cls.by_id(link.row_id).one())
            return Result(rsl, description)
        except NoSingleResultFoundError as e:
            raise NoSingleResultFoundError(
                f"error while {description}, {e}")
        except NoResultError as e:
            raise NoResultError(
                f"error while {description}, {e}")

    @classmethod
    def __validate_single_field(cls, field_name: str, value: Any) -> dict[str, Any] | tuple[dict[str, Any], dict[str, Any] | None, set[str]]:
        return cls.__pydantic_validator__.validate_assignment(
            cls.model_construct(), field_name, value
        )

    def update(self, **kwargs: Any):
        """
        Updates the fields specified by kwargs. The given keys and values are
        validated against the model. If the value type is itself a 
        """
        for key, value in kwargs.items():
            self.__validate_single_field(key, value)

    def add(self):
        Client().create_database_table_row(
            self.table_id,
            self.model_dump(by_alias=True),
            user_field_names=True
        )
