"""
This module contains a thin wrapper around the Baserow Client library.
"""

from .config import settings
from .log import logger

from typing import Generic, List, Optional, Type, TypeVar, Union

from baserow.client import ApiError, BaserowClient
from baserow.filter import Column, Filter
from pydantic import BaseModel, ConfigDict, Field
from pydantic.root_model import RootModel


T = TypeVar("T", bound="Table")


class NoSingleResultFoundError(Exception):
    """
    Exception which is thrown if, contrary to the instruction, more than one
    entry is found by a query.
    """
    pass


class NoResultError(Exception):
    """
    If a query is expected to return at least one record but none are found,
    this exception will be thrown.
    """


class RowLink(BaseModel):
    """A single link to another table."""
    row_id: int = Field(alias="id")
    key: Optional[str] = Field(alias="value")


class TableLinkField(RootModel[list[RowLink]]):
    """
    Table link field. Can contain one or more links to rows in another table.
    """
    root: list[RowLink]

    def id_str(self) -> str:
        """Returns a list of all ID's as string for debugging."""
        return ",".join([str(link.row_id) for link in self.root])


class Client(BaserowClient):
    """
    Encapsulates the baserow client into a singleton and provides some extra validation methods.
    """
    _instance = None
    __initialized = False

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.__initialized = False
        return cls._instance

    def __init__(self):
        if not self.__initialized:
            super().__init__(settings.baserow_url, token=settings.baserow_api_key)
            self.__initialized = True


class Result(Generic[T]):
    """
    Result of a query. Supports additional checking and post-processing of
    results.
    """

    def __init__(self, value: list[T], query_explanation: str = ""):
        """
        The query_explanation provides a clear and understandable explanation of
        the query that the result is based on. It is used in error messages
        generated by the filters. Should complete the sentence "when...".
        """
        self.__value = value
        self.__query_description = query_explanation

    def any(self) -> list[T]:
        """Returns the result as list without any additional checks."""
        return self.__value

    def one(self) -> T:
        """
        Exactly one entry is expected to be within the result. This is useful,
        for example, if you're searching for an existing entry by its unique ID.
        If this requirement is not met, a `NoSingleResultFoundError` is thrown.
        """
        if len(self.__value) == 0:
            raise NoSingleResultFoundError(
                f"empty result when {self.__query_description}, exactly one result expected"
            )
        if len(self.__value) > 1:
            raise NoSingleResultFoundError(
                f"more than one result when {self.__query_description}, exactly one result expected"
            )
        return self.__value[0]

    def not_none(self) -> list[T]:
        """Returns the result(s) as a list if there is at least one record present."""
        if len(self.__value) == 0:
            raise NoResultError(
                f"expected at least one record when {self.__query_description}, zero results were returned"
            )
        return self.__value

    def is_empty(self) -> bool:
        """Checks whether result contains any results."""
        return len(self.__value) > 0


class TableConfig(ConfigDict):
    """
    This is a ConfigDict extension that includes custom settings for connecting with Baserow.
    """
    table_id: int
    table_name: str


class Table(BaseModel):
    """
    Encapsulates the most common interactions with a baserow table by binding it to a pydantic
    BaseModel.
    """

    @classmethod
    def validate_baserow(cls):
        """
        Checks if the given table id's exist in the Baserow backend. And the given user field
        names exist in the table.
        """
        table_id = cls.table_id()
        table_name = cls.table_name()
        aliases = [field.alias for _, field in cls.model_fields.items()]
        try:
            result = Client().list_database_table_fields(table_id)
            field_names = [field.name for field in result]
            for alias in aliases:
                if alias not in field_names and alias != "id":
                    raise RuntimeError(
                        f"Field '{alias}' not found in Baserow {table_name} table {table_id}"
                    )
        except ApiError as e:
            if e.args[0] == "ERROR_TABLE_DOES_NOT_EXIST":
                raise RuntimeError(
                    f"There is no {table_name} table in baserow for id {table_id}")
            raise e

    @classmethod
    def query(
        cls: Type[T],
        filter: List[Filter],
        # one: bool = False,
        # not_none: bool = False,
    ) -> Result[T]:
        """
        Queries rows in the table If no results are found, the function will
        return `None`. Otherwise, the results will be returned as a list. The
        model instance will only be returned without being encapsulated in a
        list if `one` is set.

        Args:
            filter: List of filter which should be applied to the query. Provide
                empty list if no filtering is desired. 
            one: Set to `True` if exactly one entry is expected to be found.
                This is useful, for example, if you're searching for an existing
                entry by its unique ID. If this requirement is not met, a
                `NoSingleResultFoundError` is thrown. Cannot be set at the same
                time as `not_none`.
            not_none: Use this if you expect your query to return at least one
                record. Will throw a `NoResultError' if the query returns an
                empty result.Cannot be set at the same time as `one`.
        """
        # if one and not_none:
        #     raise ValueError(
        #         "The 'one' and 'not_none' parameters cannot both be true in the query method."
        #     )

        response = Client().list_database_table_rows(
            cls.table_id(),
            filter=filter,
            user_field_names=True,
        )
        return Result(
            [cls.model_validate(result) for result in response.results],
            f"querying  table {cls.table_id()} ({cls.table_name()}) with filter '{filter}'",
        )

        if one and response.count != 1:
            raise NoSingleResultFoundError(
                f"when querying table {cls.table_id()} ({cls.table_name()}) with filter '{filter}', only one record was expected, but {response.count} results were returned instead."
            )
        if not_none and response.count < 1:
            raise NoResultError(
                f"expected at least one record when querying table {cls.table_id()} ({cls.table_name()}) with filter '{filter}'. However, zero results were returned instead."
            )

        if one:
            return cls.model_validate(response.results[0])
        if response.count == 0:
            return None
        return [cls.model_validate(result) for result in response.results]

    @classmethod
    def by_uuid(cls: Type[T], uuid: str) -> Result[T]:
        logger.debug(f"baserow query in {cls.table_name()} by UUID {uuid}")
        return cls.query([Column("UUID").equal(uuid)])

    @classmethod
    def by_id(cls: Type[T], row_id: int) -> Result[T]:
        """
        Retrieve an entry by its unique row ID.
        """
        logger.debug(f"baserow query in {cls.table_name()} by ID {row_id}")
        response = Client().get_database_table_row(
            cls.table_id(),
            row_id,
            user_field_names=True,
        )
        return Result(
            [cls.model_validate(response)],
            f"querying the table with the unique ID '{row_id}' for {cls.table_name()} ({cls.table_id()})",
        )
        if not_none and len(response) == 0:
            raise NoResultError(
            )
        return cls.model_validate(response)

    @classmethod
    def by_link_field(
        cls: Type[T],
        link_field: TableLinkField,
        # one: bool = False,
        # not_none: bool = False,
    ) -> Result[T]:
        """
        Get entries by a TableLinkField values. Used to retrieve linked table rows.

        Args:
            one: Set to `True` if exactly one entry is expected to be found.
                This is useful, for example, if you're searching for an existing
                entry by its unique ID. If this requirement is not met, a
                `NoSingleResultFoundError` is thrown. Cannot be set at the same
                time as `not_none`.
            not_none: Use this if you expect your query to return at least one
                record. Will throw a `NoResultError' if the query returns an
                empty result.Cannot be set at the same time as `one`.
        """
        description = f"query in {cls.table_name()} for linked fields with ID's [{link_field.id_str()}]"
        logger.debug(
            f"baserow {description}"
        )
        rsl: List[T] = []
        try:
            for link in link_field.root:
                rsl.append(cls.by_id(link.row_id).one())
            return Result(rsl, description)
        except NoSingleResultFoundError as e:
            raise NoSingleResultFoundError(
                f"error while {description}, {e}")
        except NoResultError as e:
            raise NoResultError(
                f"error while {description}, {e}")

        # if one and len(rsl) != 1:
        #     raise NoSingleResultFoundError(
        #         f"when querying for linked rows in table {cls.table_id()} ({cls.table_name()}) with id's [{link_field.id_str()}], only one record was expected, but {len(rsl)} results were found"
        #     )
        # if not_none and len(rsl) == 0:
        #     raise NoResultError(
        #         f"expected at least one record when querying for linked rows in table {cls.table_id()} ({cls.table_name()}) with id's [{link_field.id_str()}] However, zero results were returned instead"
        #     )

        # if one:
        #     return rsl[0]
        # if len(rsl) == 0:
        #     return None
        # return rsl

    @classmethod
    def table_id(cls) -> int:
        rsl = cls.model_config.get('table_id')
        if not isinstance(rsl, int):
            raise RuntimeError(f"table_id is not configured in a table model")
        return rsl

    @classmethod
    def table_name(cls):
        rsl = cls.model_config.get('table_name')
        if not isinstance(rsl, str):
            raise RuntimeError(
                f"table_name is not configured in a table model"
            )
        return rsl

    def add(self):
        Client().create_database_table_row(
            self.table_id(),
            self.model_dump(by_alias=True),
            user_field_names=True
        )
